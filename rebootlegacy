Here’s how to use PsExec to execute PowerShell commands remotely to retrieve details about Event ID 1074 from the event logs of servera. The command will focus on querying the System log for clean reboot events (Event ID 1074).

Step-by-Step Guide
1. Prerequisites
Ensure you have:
PsExec installed on the system running the script.
Administrative privileges for both the local and remote machines.
Port 445 open for communication with servera.
2. PowerShell Command to Query Event Logs
The following PowerShell command will query the System event log for Event ID 1074:

powershell
Copy code
Get-WinEvent -LogName System -FilterHashtable @{ID=1074} | Select-Object TimeCreated, Message
3. Command to Use with PsExec
Here’s how to structure the PsExec command to run the PowerShell query on servera:

cmd
Copy code
psexec \\servera -s powershell.exe -Command "Get-WinEvent -LogName System -FilterHashtable @{ID=1074} | Select-Object TimeCreated, Message"
Explanation:
\\servera: Specifies the target server.
-s: Runs the command as SYSTEM on the remote machine.
powershell.exe -Command: Runs the specified PowerShell command.
Get-WinEvent -LogName System -FilterHashtable @{ID=1074}: Retrieves only Event ID 1074 from the System log.
Select-Object TimeCreated, Message: Displays the event timestamp and the message.
4. Outputting to a File
To save the output of the query to a file on your local machine, modify the PsExec command like this:

cmd
Copy code
psexec \\servera -s powershell.exe -Command "Get-WinEvent -LogName System -FilterHashtable @{ID=1074} | Select-Object TimeCreated, Message | Out-File -FilePath C:\Temp\Event1074_Logs.txt"
Explanation:
Out-File -FilePath C:\Temp\Event1074_Logs.txt: Saves the output to a file on the remote server (servera) in the C:\Temp directory.
5. Copy the Output File to the Local Machine
Once the log file is created on the remote server, you can copy it back to your local machine using the following command:

cmd
Copy code
psexec \\servera -s cmd /c "copy C:\Temp\Event1074_Logs.txt \\<your_local_machine>\C$\Temp\"
Replace <your_local_machine> with the name of your local machine. Ensure that the C$\Temp directory exists on your machine.

6. Combined Script to Automate the Process
Here’s a batch script to automate the entire process:

bat
Copy code
@echo off

REM Define server
set SERVER=servera

REM Define remote and local paths
set REMOTE_PATH=C:\Temp\Event1074_Logs.txt
set LOCAL_PATH=C:\Temp\Event1074_Logs_%SERVER%.txt

REM Run the PowerShell command remotely
psexec \\%SERVER% -s powershell.exe -Command "Get-WinEvent -LogName System -FilterHashtable @{ID=1074} | Select-Object TimeCreated, Message | Out-File -FilePath %REMOTE_PATH%"

REM Copy the file back to the local machine
psexec \\%SERVER% -s cmd /c "copy %REMOTE_PATH% \\%COMPUTERNAME%\C$\Temp\Event1074_Logs_%SERVER%.txt"

REM Confirm completion
echo Logs have been copied to %LOCAL_PATH%.
pause
7. Verify and Review Logs
Run the batch script or the individual commands in a Command Prompt with administrative privileges.
Check the C:\Temp directory on your local machine for the file Event1074_Logs_servera.txt.
Open the file to review the clean reboot events.
Notes:
Error Handling: Ensure PsExec has the necessary permissions to access servera. If errors occur, check firewall settings and the availability of administrative shares (ADMIN$).
Alternative for Older PowerShell: If Get-WinEvent is not available on Windows 2008, use Get-EventLog instead:
powershell
Copy code
Get-EventLog -LogName System -InstanceId 1074 | Select-Object TimeGenerated, Message



#############################################################################################################################################################################################


Using PsExec for Windows Server 2008 to retrieve event logs for reboots or unexpected crashes involves querying the Event Logs for specific Event IDs. The relevant IDs for system reboots or crashes are:

Event ID 41: Kernel-Power (unexpected shutdown/crash).
Event ID 1074: Clean reboot initiated by a process or user.
Event ID 6006: Clean shutdown.
Event ID 6008: Unexpected shutdown.
Here’s a script to automate this using PsExec:

Script Details
Tool Required: PsExec from Sysinternals.
Target Servers: servera, serverb, serverc.
Query: Use wevtutil to extract the logs since PowerShell features on Windows 2008 are limited.
Script: GetRebootLogs.bat
Save the following script as a .bat file:

bat
Copy code
@echo off
setlocal enabledelayedexpansion

REM Define the list of servers
set SERVERS=servera serverb serverc

REM Path to output results
set OUTPUT_PATH=C:\RebootLogs
mkdir "%OUTPUT_PATH%"

echo Querying event logs for reboots and crashes...

REM Loop through each server
for %%S in (%SERVERS%) do (
    echo ==========================================
    echo Connecting to %%S...
    echo ==========================================

    REM Use PsExec to run wevtutil on the remote server
    psexec \\%%S -s -h cmd /c ^
    "wevtutil qe System /q:*[System[Provider[@Name='Microsoft-Windows-Kernel-Power'] and (EventID=41)]] /f:text > %%TEMP%%\Reboot_Crash_Logs.txt & ^
    wevtutil qe System /q:*[System[Provider[@Name='EventLog'] and (EventID=6008)]] /f:text >> %%TEMP%%\Reboot_Crash_Logs.txt & ^
    wevtutil qe System /q:*[System[Provider[@Name='EventLog'] and (EventID=6006 or EventID=1074)]] /f:text >> %%TEMP%%\Reboot_Crash_Logs.txt & ^
    copy %%TEMP%%\Reboot_Crash_Logs.txt \"%OUTPUT_PATH%\%%S_RebootLogs.txt\" & ^
    del %%TEMP%%\Reboot_Crash_Logs.txt"

    echo Logs collected for %%S. See %%OUTPUT_PATH%%\%%S_RebootLogs.txt
)

echo Logs are saved in %OUTPUT_PATH%.
pause
Explanation of the Script:
Define Servers:

The script loops through the list of servers (servera, serverb, serverc) defined in the SERVERS variable.
Log Queries:

wevtutil queries the System event log for relevant events:
Event ID 41: Kernel-Power (unexpected crashes).
Event ID 6008: Unexpected shutdowns.
Event IDs 6006, 1074: Clean shutdowns/reboots.
Output Location:

Logs are saved in C:\RebootLogs\ on the machine running the script. Each server gets a separate log file (servera_RebootLogs.txt, etc.).
PsExec Usage:

psexec \\server -s -h runs the command on the remote server with system privileges (-s) and ensures elevated rights (-h).
Temporary Files:

Logs are temporarily saved on the remote machine in %TEMP% and copied back to the local system.
Steps to Execute:
Download PsExec:

Download PsExec from Sysinternals.
Copy PsExec to a Directory in the PATH:

Ensure PsExec.exe is accessible globally (e.g., place it in C:\Windows\System32).
Run the Script:

Save the script as GetRebootLogs.bat.
Open Command Prompt as Administrator.
Run the script: GetRebootLogs.bat.
Review Logs:

Check the C:\RebootLogs directory for the log files for each server.
Notes:
Administrative Privileges: Ensure you have admin access to the target servers.
Firewall Rules: Make sure PsExec can communicate with the servers (default TCP port 445 must be open).
Compatibility: This script is designed for Windows 2008. For newer servers, PowerShell remoting with advanced cmdlets like Get-WinEvent is recommended.

#############################################################################################################################################################################################










The error message indicates that the PowerShell script is unable to connect to the specified IP address (172.22.123.54) due to an issue with WinRM (Windows Remote Management). Here’s how you can resolve the issue:



Steps to Resolve

1. Enable WinRM on the Target Machine

• Open PowerShell on the target machine (172.22.123.54) as an administrator.

• Run the following command to enable WinRM:



Enable-PSRemoting -Force





2. Add the IP Address to the TrustedHosts List

• On the machine running the script, add the target IP address to the TrustedHosts list:



Set-Item wsman:\localhost\Client\TrustedHosts -Value "172.22.123.54" -Force





• If multiple IP addresses need to be trusted, use a comma-separated list:



Set-Item wsman:\localhost\Client\TrustedHosts -Value "172.22.123.54,192.168.1.1" -Force





3. Ensure HTTPS or Credentials Are Set

• If you are not using HTTPS, ensure explicit credentials are provided in the script. Use the following command to create a credential object:



$cred = Get-Credential





• Pass $cred to the Invoke-Command or Enter-PSSession commands in your script.



4. Test Network Connectivity

• Make sure the machine running the script can ping the target machine:



Test-Connection -ComputerName 172.22.123.54





5. Check the WinRM Service

• Ensure the WinRM service is running on both the target and source machines:



Get-Service -Name WinRM





• If the service is not running, start it:



Start-Service -Name WinRM





6. Firewall Rules

• Ensure that firewall rules on both machines allow WinRM traffic. Open port 5985 (HTTP) or 5986 (HTTPS):



New-NetFirewallRule -Name "WinRM HTTP" -DisplayName "Allow WinRM HTTP" -Protocol TCP -LocalPort 5985 -Action Allow





7. Verify PowerShell Script

• Ensure your script explicitly specifies the IP address and uses the correct credentials. For example:



Invoke-Command -ComputerName 172.22.123.54 -Credential $cred -ScriptBlock { 

    # Your code here

}





8. Restart WinRM

• On the target machine, restart the WinRM service:



Restart-Service -Name WinRM







Additional Debugging



If the issue persists, run the following diagnostic command:



winrm id



This checks whether WinRM is properly configured on the target machine.



After performing these steps, your script should be able to connect and execute the desired commands on the remote machine.

######################################################################################################################################################################


"Intelligent Server Reboot Diagnostics and Notification Framework"
Description for Management:

"Our Intelligent Server Reboot Diagnostics and Notification Framework leverages SolarWinds and custom PowerShell scripts to provide automated, 
real-time notifications and root cause analysis for every server reboot. By intelligently identifying patterns and root causes—such as blue screens, user-initiated reboots, 
or other issues—it ensures faster and more accurate diagnostics. This proactive workflow eliminates error-prone manual diagnostics, accelerates response times, and improves 
the ability to detect and address recurring issues."

Why This Works:
"Intelligent": Highlights advanced analysis and pattern detection.
"Faster Root Cause Analysis": Emphasizes efficiency and the value of reducing downtime.
"Removes Error Diagnostics": Reassures management that the process is reliable and minimizes human error.
"Patterns": Adds a layer of forward-looking capability, such as detecting trends for preventive action.







"Intelligent Server Reboot Diagnostics and Notification Framework" PowerPoint presentation.

1️⃣ Title Slide
Concepts to Highlight: Intelligence, Automation, and System Monitoring

Image Ideas:

Futuristic AI Brain with glowing circuits (symbolizing "intelligent diagnostics").
Abstract Server Icons with connections to gears or flowcharts (representing "workflow").
Network Monitoring Dashboard UI (symbolizing SolarWinds and live dashboards).
Gears Interlocked (symbolizing an automated and well-coordinated process).
2️⃣ Slide: Workflow Process (Visualizing the Process)
Concepts to Highlight: Process Flow, Automation, Workflow

Image Ideas:

Process Flow Diagram (arrows flowing through key steps like "Reboot Detected → PowerShell Script Triggered → Cause Analysis → Email Notification").
Modern Data Flow with Server Icons (show a server with arrows leading to a screen, symbolizing data collection).
Automation Gears with a Server at the Center (show the process as a system with gears around the server).
Server Rack with Power On/Off Symbol (visual for reboot events).
3️⃣ Slide: Intelligent Root Cause Analysis
Concepts to Highlight: Root Cause Analysis, Error Detection, Patterns

Image Ideas:

Magnifying Glass Over a Server (symbolizing analysis and investigation).
Error Report with Visual Highlights (representing log analysis and troubleshooting).
Data Visualization (bar graphs, line graphs, or event timelines showing how patterns are detected).
AI Brain Over a Dashboard (symbolizing "intelligent analysis" of system logs).
4️⃣ Slide: Real-Time Notifications
Concepts to Highlight: Notifications, Alerts, Speed, Proactive Response

Image Ideas:

Email Alert Icon on a Smartphone (showing mobile notifications in real time).
Pop-up Notification on a Screen (visual of an alert message on a computer screen).
Bell Icon with Alert Notification (universal icon for notifications).
Stopwatch Icon Next to Alert (symbolizing speed and instant action).
5️⃣ Slide: Eliminating Human Error
Concepts to Highlight: Accuracy, Precision, Reduction of Human Error

Image Ideas:

Robot Replacing a Human Hand (symbolizing the transition from manual to automated processes).
Checklist with Green Check Marks (representing task completion and accuracy).
Human Silhouette Next to a Robot (symbolizing the shift from manual error-prone work to intelligent automation).
Crossed-Out Error Icon (universal symbol for eliminating errors).
6️⃣ Slide: Faster Pattern Detection
Concepts to Highlight: Trends, Data Analytics, Pattern Recognition

Image Ideas:

Trend Line on a Graph (highlighting the detection of patterns or anomalies).
Heatmap of Server Issues (a visual indicator of problem frequency).
AI Data Analysis Icons (symbols for machine learning, pattern recognition, and analysis).
Server Uptime/Downtime Timeline (visual representation of recurring downtime/reboots).
7️⃣ Slide: Proactive, Intelligent, and Automated System
Concepts to Highlight: Proactivity, Intelligence, Automation

Image Ideas:

Robot Monitoring a Dashboard (symbolizing autonomous, intelligent monitoring).
Shield Icon (representing security, intelligence, and automation protection).
Network Control Center Image (a control room image showing proactive system oversight).
AI Chip with Gear Icon (emphasizing intelligent automation).
8️⃣ Slide: Value to the Business (Benefits)
Concepts to Highlight: Time Savings, Risk Reduction, Cost Reduction, Business Impact

Image Ideas:

Clock Icon with Money Bag (symbolizing time savings and cost reduction).
Bar Chart Showing Error Reduction (representing quantifiable improvements).
Server Room Image with Glowing Blue Lights (visuals of a modern, "futuristic" server room).
Before and After Visual (split-screen showing manual process vs. automated process).
9️⃣ Slide: Call to Action (Next Steps)
Concepts to Highlight: Action, Implementation, Next Steps

Image Ideas:

Arrow Pointing Forward (universal "forward movement" symbol).
To-Do List Icon (representing a plan for next steps).
Team of People Around a Conference Table (symbolizing teamwork and moving forward).
Blueprint or Roadmap (representing planning and strategic implementation).
Custom Image/Diagram Ideas
If you want something more personalized, you can request a custom process flow diagram with the following elements:

Server Icon (representing reboot detection) →
PowerShell Script Icon (representing cause analysis) →
AI Brain Icon (representing pattern detection) →
Email Icon (representing alert/notification) →
Admin Icon with Monitor (representing visibility and decision-making).






##################logging#########################################


Enable PerfMon to Log CPU and Memory on Each Server
You can set up Performance Monitor (PerfMon) on each server to track CPU and memory every minute. Here’s how to do it.

Steps:

Open Performance Monitor (perfmon.exe).
Go to Data Collector Sets → User Defined → New → Data Collector Set.
Name it "System CPU and Memory Log".
Choose Create Manually (Advanced).
Performance Counters:
Click Add Counters.
Add these two counters:
Processor(_Total)% Processor Time (to track CPU usage)
Memory\Available MBytes (to track available memory)
Sample Interval: Set it to 1 minute (00:01:00).
File Storage:
Set it to store in C:\PerfLogs or a location of your choice.
Rolling Log: Use circular logging (overwrite old data after 24 hours).
Automate This Process:

You can export this Data Collector Set as an XML and import it into the other 1000 servers.
Use PowerShell or Group Policy to deploy the PerfMon Data Collector Set across multiple servers.
2️⃣ Script to Automatically Enable PerfMon on All Servers
Here’s a PowerShell script to deploy the PerfMon configuration to all 1000 servers.

powershell
Copy code
$serverList = @("servera", "serverb", "serverc")  # Add all 1000 server names here
$perfmonName = "System CPU and Memory Log"

foreach ($server in $serverList) {
    Write-Host "Configuring PerfMon on $server..."
    Invoke-Command -ComputerName $server -ScriptBlock {
        # Create the Data Collector Set
        New-Item -Path "C:\PerfLogs" -ItemType Directory -ErrorAction SilentlyContinue
        $counterList = @(
            "\Processor(_Total)\% Processor Time",
            "\Memory\Available MBytes"
        )
        
        $dcSetName = "System CPU and Memory Log"
        $dcPath = "C:\PerfLogs\%COMPUTERNAME%_Perfmon.blg"
        $interval = 60  # 1 minute interval
        $duration = 86400  # 24-hour rolling log (24 hours * 3600 seconds)

        $command = "logman.exe create counter `"$dcSetName`" -c `"$($counterList -join ',')`" -si $interval -o `"$dcPath`" -v mmddhhmm -f bincirc -rf $duration"
        Invoke-Expression $command

        # Start the Data Collector Set
        logman start $dcSetName
    }
}
What It Does:

Loops through all your servers (servera, serverb, serverc).
Sets up Performance Counter logs for CPU and Memory.
Uses a rolling 24-hour log that automatically clears old data.
Stores the file in C:\PerfLogs on each server.
3️⃣ When an Issue is Detected (Trigger the Log Collection)
Now that each server is already collecting logs, you only "activate" the logs if a problem occurs (like high CPU, memory, etc.).

How to Detect Issues

Use SolarWinds Alerts: When SolarWinds detects high CPU or memory, trigger an action.
Call a Script: The alert can run a PowerShell script that copies the PerfMon log from the affected server to a central storage location for investigation.
4️⃣ Script to Pull Logs for Root Cause Analysis
Here’s the PowerShell script to pull the rolling logs from a server.

powershell
Copy code
$serverList = @("servera", "serverb", "serverc")  # Replace with your server list
$centralStorage = "\\centralserver\Logs\ServerPerfLogs"

foreach ($server in $serverList) {
    $remotePath = "\\$server\C$\PerfLogs"
    $localPath = "$centralStorage\$server"

    # Create directory for server logs
    New-Item -Path $localPath -ItemType Directory -Force

    # Copy latest PerfMon files from the remote server
    Copy-Item -Path "$remotePath\*.blg" -Destination $localPath -Force
}
What It Does:

When an issue is detected, SolarWinds can call this script.
It pulls the latest .blg files (Performance Log) from C:\PerfLogs on each server.
Copies the logs to a central location for root-cause analysis.
Pros of This Approach
Category	Description
Storage	Uses only 1 rolling log file per server, avoiding centralized data overload.
Resource Usage	Minimal overhead (PerfMon is lightweight).
Data Retention	24-hour history is perfect for after-incident analysis.
On-Demand Use	Logs are always ready but only accessed when needed.
Easy to Implement	Uses native tools (PerfMon, PowerShell) with no licensing costs.
Scalability	Works for 1000+ servers as no central server is required to hold logs.
Potential Issues
Challenge	Solution
Disk Space Usage	Use 24-hour rolling logs, limit log size, or store on separate partitions.
Log File Size	The file size depends on process count and logging interval (usually <100MB/day).
Log Access	If a server goes down, log files are on the downed server, but you can collect them on a schedule.
Automation	Automate with PowerShell to ensure logs are always running.
Summary
Approach: Use PerfMon on each server to log CPU and memory usage every minute.
Storage: Keep logs for 24 hours and automatically delete old data.
Usage: Only access these logs when an issue occurs.
How it Works:
Logs are stored locally on each server.
Use SolarWinds alerts to trigger a log copy for deeper analysis.
PowerShell automation can ensure logs are running on all 1000 servers.
Efficiency: Uses minimal network, disk, and CPU overhead.
Scalability: Can scale to thousands of servers.

